import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { performanceMonitor } from '@/lib/performance';\nimport { dbOptimizer } from '@/lib/database-optimizer';\nimport { cache } from '@/lib/cache';\nimport { connectionPool, memoryMonitor } from '@/middleware/performance';\nimport { prisma } from '@awcrm/database';\n\nexport async function GET(req: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n\n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    // Check if user has admin access\n    const user = await prisma.user.findUnique({\n      where: { id: session.user.id },\n      select: { role: true },\n    });\n\n    if (!user || (user.role !== 'ADMIN' && user.role !== 'MANAGER')) {\n      return NextResponse.json(\n        { error: 'Insufficient permissions' },\n        { status: 403 }\n      );\n    }\n\n    // Get comprehensive performance statistics\n    const [performanceStats, dbHealth, cacheHealth, memoryStatus, connectionStats] = await Promise.all([\n      performanceMonitor.getPerformanceStats(),\n      dbOptimizer.getDatabaseHealth(),\n      cache.healthCheck(),\n      memoryMonitor.checkMemoryUsage(),\n      Promise.resolve(connectionPool.getStats()),\n    ]);\n\n    // Get recent performance alerts\n    const { alerts } = await performanceMonitor.checkPerformanceAlerts();\n\n    // Get query optimization suggestions\n    const { suggestions } = await dbOptimizer.analyzeQueryPerformance();\n\n    const stats = {\n      timestamp: new Date().toISOString(),\n      performance: performanceStats,\n      database: {\n        health: dbHealth,\n        connections: connectionStats,\n      },\n      cache: {\n        health: cacheHealth,\n        hitRate: performanceStats.cache.hitRate,\n        totalHits: performanceStats.cache.totalHits,\n        totalMisses: performanceStats.cache.totalMisses,\n      },\n      memory: {\n        usage: {\n          heapUsed: Math.round(memoryStatus.usage.heapUsed / 1024 / 1024), // MB\n          heapTotal: Math.round(memoryStatus.usage.heapTotal / 1024 / 1024), // MB\n          rss: Math.round(memoryStatus.usage.rss / 1024 / 1024), // MB\n          external: Math.round(memoryStatus.usage.external / 1024 / 1024), // MB\n        },\n        warning: memoryStatus.warning,\n        critical: memoryStatus.critical,\n      },\n      alerts,\n      suggestions,\n      system: {\n        uptime: process.uptime(),\n        nodeVersion: process.version,\n        platform: process.platform,\n        arch: process.arch,\n      },\n    };\n\n    return NextResponse.json({\n      success: true,\n      stats,\n    });\n  } catch (error) {\n    console.error('Performance stats error:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch performance statistics' },\n      { status: 500 }\n    );\n  }\n}\n"