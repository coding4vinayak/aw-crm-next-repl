import Redis from 'ioredis';\n\nclass CacheService {\n  private redis: Redis | null = null;\n  private memoryCache = new Map<string, { value: any; expires: number }>();\n  private readonly defaultTTL = 3600; // 1 hour in seconds\n\n  constructor() {\n    this.initializeRedis();\n  }\n\n  private async initializeRedis() {\n    try {\n      if (process.env.REDIS_URL) {\n        this.redis = new Redis(process.env.REDIS_URL, {\n          retryDelayOnFailover: 100,\n          maxRetriesPerRequest: 3,\n          lazyConnect: true,\n        });\n\n        this.redis.on('error', (error) => {\n          console.error('Redis connection error:', error);\n          this.redis = null; // Fall back to memory cache\n        });\n\n        this.redis.on('connect', () => {\n          console.log('Redis connected successfully');\n        });\n\n        // Test connection\n        await this.redis.ping();\n      } else {\n        console.warn('Redis URL not provided, using memory cache');\n      }\n    } catch (error) {\n      console.error('Failed to initialize Redis:', error);\n      this.redis = null;\n    }\n  }\n\n  // Generic cache operations\n  async get<T = any>(key: string): Promise<T | null> {\n    try {\n      if (this.redis) {\n        const value = await this.redis.get(key);\n        return value ? JSON.parse(value) : null;\n      } else {\n        // Fall back to memory cache\n        const cached = this.memoryCache.get(key);\n        if (cached && cached.expires > Date.now()) {\n          return cached.value;\n        } else if (cached) {\n          this.memoryCache.delete(key);\n        }\n        return null;\n      }\n    } catch (error) {\n      console.error('Cache get error:', error);\n      return null;\n    }\n  }\n\n  async set(key: string, value: any, ttl: number = this.defaultTTL): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.setex(key, ttl, JSON.stringify(value));\n      } else {\n        // Fall back to memory cache\n        this.memoryCache.set(key, {\n          value,\n          expires: Date.now() + (ttl * 1000),\n        });\n      }\n    } catch (error) {\n      console.error('Cache set error:', error);\n    }\n  }\n\n  async del(key: string): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.del(key);\n      } else {\n        this.memoryCache.delete(key);\n      }\n    } catch (error) {\n      console.error('Cache delete error:', error);\n    }\n  }\n\n  async exists(key: string): Promise<boolean> {\n    try {\n      if (this.redis) {\n        return (await this.redis.exists(key)) === 1;\n      } else {\n        const cached = this.memoryCache.get(key);\n        return cached ? cached.expires > Date.now() : false;\n      }\n    } catch (error) {\n      console.error('Cache exists error:', error);\n      return false;\n    }\n  }\n\n  async flush(): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.flushall();\n      } else {\n        this.memoryCache.clear();\n      }\n    } catch (error) {\n      console.error('Cache flush error:', error);\n    }\n  }\n\n  // Pattern-based operations\n  async getPattern(pattern: string): Promise<string[]> {\n    try {\n      if (this.redis) {\n        return await this.redis.keys(pattern);\n      } else {\n        // Simple pattern matching for memory cache\n        const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n        return Array.from(this.memoryCache.keys()).filter(key => regex.test(key));\n      }\n    } catch (error) {\n      console.error('Cache pattern get error:', error);\n      return [];\n    }\n  }\n\n  async delPattern(pattern: string): Promise<void> {\n    try {\n      const keys = await this.getPattern(pattern);\n      if (keys.length > 0) {\n        if (this.redis) {\n          await this.redis.del(...keys);\n        } else {\n          keys.forEach(key => this.memoryCache.delete(key));\n        }\n      }\n    } catch (error) {\n      console.error('Cache pattern delete error:', error);\n    }\n  }\n\n  // Hash operations (for complex data structures)\n  async hget(key: string, field: string): Promise<any> {\n    try {\n      if (this.redis) {\n        const value = await this.redis.hget(key, field);\n        return value ? JSON.parse(value) : null;\n      } else {\n        const hash = this.memoryCache.get(key);\n        if (hash && hash.expires > Date.now() && hash.value[field]) {\n          return hash.value[field];\n        }\n        return null;\n      }\n    } catch (error) {\n      console.error('Cache hget error:', error);\n      return null;\n    }\n  }\n\n  async hset(key: string, field: string, value: any, ttl: number = this.defaultTTL): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.hset(key, field, JSON.stringify(value));\n        await this.redis.expire(key, ttl);\n      } else {\n        const existing = this.memoryCache.get(key);\n        const hashValue = existing && existing.expires > Date.now() ? existing.value : {};\n        hashValue[field] = value;\n        this.memoryCache.set(key, {\n          value: hashValue,\n          expires: Date.now() + (ttl * 1000),\n        });\n      }\n    } catch (error) {\n      console.error('Cache hset error:', error);\n    }\n  }\n\n  async hdel(key: string, field: string): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.hdel(key, field);\n      } else {\n        const hash = this.memoryCache.get(key);\n        if (hash && hash.value[field]) {\n          delete hash.value[field];\n        }\n      }\n    } catch (error) {\n      console.error('Cache hdel error:', error);\n    }\n  }\n\n  // List operations (for queues, recent items, etc.)\n  async lpush(key: string, value: any): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.lpush(key, JSON.stringify(value));\n      } else {\n        const list = this.memoryCache.get(key);\n        const listValue = list && list.expires > Date.now() ? list.value : [];\n        listValue.unshift(value);\n        this.memoryCache.set(key, {\n          value: listValue,\n          expires: Date.now() + (this.defaultTTL * 1000),\n        });\n      }\n    } catch (error) {\n      console.error('Cache lpush error:', error);\n    }\n  }\n\n  async lrange(key: string, start: number = 0, stop: number = -1): Promise<any[]> {\n    try {\n      if (this.redis) {\n        const values = await this.redis.lrange(key, start, stop);\n        return values.map(v => JSON.parse(v));\n      } else {\n        const list = this.memoryCache.get(key);\n        if (list && list.expires > Date.now()) {\n          return list.value.slice(start, stop === -1 ? undefined : stop + 1);\n        }\n        return [];\n      }\n    } catch (error) {\n      console.error('Cache lrange error:', error);\n      return [];\n    }\n  }\n\n  // Set operations (for unique collections)\n  async sadd(key: string, value: any): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.sadd(key, JSON.stringify(value));\n      } else {\n        const set = this.memoryCache.get(key);\n        const setValue = set && set.expires > Date.now() ? new Set(set.value) : new Set();\n        setValue.add(JSON.stringify(value));\n        this.memoryCache.set(key, {\n          value: Array.from(setValue),\n          expires: Date.now() + (this.defaultTTL * 1000),\n        });\n      }\n    } catch (error) {\n      console.error('Cache sadd error:', error);\n    }\n  }\n\n  async smembers(key: string): Promise<any[]> {\n    try {\n      if (this.redis) {\n        const values = await this.redis.smembers(key);\n        return values.map(v => JSON.parse(v));\n      } else {\n        const set = this.memoryCache.get(key);\n        if (set && set.expires > Date.now()) {\n          return set.value.map((v: string) => JSON.parse(v));\n        }\n        return [];\n      }\n    } catch (error) {\n      console.error('Cache smembers error:', error);\n      return [];\n    }\n  }\n\n  // Increment operations (for counters)\n  async incr(key: string): Promise<number> {\n    try {\n      if (this.redis) {\n        return await this.redis.incr(key);\n      } else {\n        const current = this.memoryCache.get(key);\n        const value = current && current.expires > Date.now() ? current.value : 0;\n        const newValue = value + 1;\n        this.memoryCache.set(key, {\n          value: newValue,\n          expires: Date.now() + (this.defaultTTL * 1000),\n        });\n        return newValue;\n      }\n    } catch (error) {\n      console.error('Cache incr error:', error);\n      return 0;\n    }\n  }\n\n  async incrby(key: string, increment: number): Promise<number> {\n    try {\n      if (this.redis) {\n        return await this.redis.incrby(key, increment);\n      } else {\n        const current = this.memoryCache.get(key);\n        const value = current && current.expires > Date.now() ? current.value : 0;\n        const newValue = value + increment;\n        this.memoryCache.set(key, {\n          value: newValue,\n          expires: Date.now() + (this.defaultTTL * 1000),\n        });\n        return newValue;\n      }\n    } catch (error) {\n      console.error('Cache incrby error:', error);\n      return 0;\n    }\n  }\n\n  // Utility methods\n  async ttl(key: string): Promise<number> {\n    try {\n      if (this.redis) {\n        return await this.redis.ttl(key);\n      } else {\n        const cached = this.memoryCache.get(key);\n        if (cached) {\n          return Math.max(0, Math.floor((cached.expires - Date.now()) / 1000));\n        }\n        return -1;\n      }\n    } catch (error) {\n      console.error('Cache ttl error:', error);\n      return -1;\n    }\n  }\n\n  async expire(key: string, ttl: number): Promise<void> {\n    try {\n      if (this.redis) {\n        await this.redis.expire(key, ttl);\n      } else {\n        const cached = this.memoryCache.get(key);\n        if (cached) {\n          cached.expires = Date.now() + (ttl * 1000);\n        }\n      }\n    } catch (error) {\n      console.error('Cache expire error:', error);\n    }\n  }\n\n  // Memory cache cleanup (for memory cache only)\n  private cleanupMemoryCache() {\n    const now = Date.now();\n    for (const [key, value] of this.memoryCache.entries()) {\n      if (value.expires <= now) {\n        this.memoryCache.delete(key);\n      }\n    }\n  }\n\n  // Start cleanup interval for memory cache\n  startCleanupInterval(intervalMs: number = 60000) {\n    if (!this.redis) {\n      setInterval(() => this.cleanupMemoryCache(), intervalMs);\n    }\n  }\n\n  // Health check\n  async healthCheck(): Promise<{ status: string; type: string; memory?: number }> {\n    try {\n      if (this.redis) {\n        await this.redis.ping();\n        return { status: 'healthy', type: 'redis' };\n      } else {\n        return {\n          status: 'healthy',\n          type: 'memory',\n          memory: this.memoryCache.size,\n        };\n      }\n    } catch (error) {\n      return { status: 'unhealthy', type: this.redis ? 'redis' : 'memory' };\n    }\n  }\n}\n\n// Create singleton instance\nconst cacheService = new CacheService();\n\n// Start cleanup for memory cache\ncacheService.startCleanupInterval();\n\nexport { cacheService as cache };\nexport default cacheService;\n"